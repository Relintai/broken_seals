tool
extends Reference

const Commons = preload("res://addons/mat_maker_gd/nodes/common/commons.gd")

#----------------------
#sdarc.mmg
#An arc as a signed distance function

#"outputs": [
#{
#	"longdesc": "The arc as a signed distance function",
#	"sdf2d": "sdArc($uv-vec2(0.5), mod($a1, 360.0)*0.01745329251, mod($a2, 360.0)*0.01745329251, $r1, $r2)",
#	"shortdesc": "Output",
#	"type": "sdf2d"
#}
#],
#"parameters": [
#{
#	"control": "Angle1.a",
#	"default": 0,
#	"label": "Angle 1",
#	"longdesc": "The first angle of the arc",
#	"max": 180,
#	"min": -180,
#	"name": "a1",
#	"shortdesc": "Angle1",
#	"step": 1,
#	"type": "float"
#},
#{
#	"control": "Angle2.a",
#	"default": 0,
#	"label": "Angle 2",
#	"longdesc": "The second angle of the arc",
#	"max": 180,
#	"min": -180,
#	"name": "a2",
#	"shortdesc": "Angle2",
#	"step": 1,
#	"type": "float"
#},
#{
#	"control": "Radius1.r",
#	"default": 0.5,
#	"label": "Radius",
#	"longdesc": "The radius of the arc",
#	"max": 1,
#	"min": 0,
#	"name": "r1",
#	"shortdesc": "Radius",
#	"step": 0.01,
#	"type": "float"
#},
#{
#	"control": "Radius11.r",
#	"default": 0.1,
#	"label": "Width",
#	"longdesc": "The width of the shape around the arc",
#	"max": 1,
#	"min": 0,
#	"name": "r2",
#	"shortdesc": "Width",
#	"step": 0.01,
#	"type": "float"
#}
#]

#----------------------
#sdboolean.mmg
#Performs a boolean operation (union, intersection or difference) between two shapes

#"inputs": [
#{
#	"default": "0.0",
#	"label": "",
#	"longdesc": "The first shape, defined as a signed distance function",
#	"name": "in1",
#	"shortdesc": "Input1",
#	"type": "sdf2d"
#},
#{
#	"default": "0.0",
#	"label": "",
#	"longdesc": "The second shape, defined as a signed distance function",
#	"name": "in2",
#	"shortdesc": "Input2",
#	"type": "sdf2d"
#}
#],
#"outputs": [
#{
#	"longdesc": "The shape generated by the boolean operation",
#	"sdf2d": "$op $in1($uv), $in2($uv))",
#	"shortdesc": "Output",
#	"type": "sdf2d"
#}
#],
#"parameters": [
#{
#	"default": 2,
#	"label": "",
#	"longdesc": "The operation performed by this node",
#	"name": "op",
#	"shortdesc": "Operation",
#	"type": "enum",
#	"values": [
#		{
#		"name": "Union",
#		"value": "min("
#		},
#		{
#		"name": "Subtraction",
#		"value": "max(-"
#		},
#		{
#		"name": "Intersection",
#		"value": "max("
#		}
#	]
#}
#],

#----------------------
#sdbox.mmg
#A rectangle described as a signed distance function

#		"code": "vec2 $(name_uv)_d = abs($uv-vec2($cx+0.5, $cy+0.5))-vec2($w, $h);",
#		"outputs": [
#			{
#				"longdesc": "The generated signed distance function",
#				"sdf2d": "length(max($(name_uv)_d,vec2(0)))+min(max($(name_uv)_d.x,$(name_uv)_d.y),0.0)",
#				"shortdesc": "Output",
#				"type": "sdf2d"
#			}
#		],
#		"parameters": [
#			{
#				"control": "Rect1.x",
#				"default": 0.5,
#				"label": "Width",
#				"longdesc": "The width of the box",
#				"max": 1,
#				"min": 0,
#				"name": "w",
#				"shortdesc": "Width",
#				"step": 0.01,
#				"type": "float"
#			},
#			{
#				"control": "Rect1.y",
#				"default": 1,
#				"label": "Height",
#				"longdesc": "The height of the box",
#				"max": 1,
#				"min": 0,
#				"name": "h",
#				"shortdesc": "Height",
#				"step": 0.01,
#				"type": "float"
#			},
#			{
#				"control": "P1.x",
#				"default": 0,
#				"label": "Center X",
#				"longdesc": "The position of the center of the box on the X axis",
#				"max": 1,
#				"min": -1,
#				"name": "cx",
#				"shortdesc": "Center.x",
#				"step": 0.01,
#				"type": "float"
#			},
#			{
#				"control": "P1.y",
#				"default": 0,
#				"label": "Center Y",
#				"longdesc": "The position of the center of the box on the Y axis",
#				"max": 1,
#				"min": -1,
#				"name": "cy",
#				"shortdesc": "Center.y",
#				"step": 0.01,
#				"type": "float"
#			}
#		],

#----------------------
#sdcircle.mmg
#A circle described as a signed distance function

#		"outputs": [
#			{
#				"longdesc": "The generated signed distance function",
#				"sdf2d": "length($uv-vec2($cx+0.5, $cy+0.5))-$r",
#				"shortdesc": "Output",
#				"type": "sdf2d"
#			}
#		],
#		"parameters": [
#			{
#				"control": "Radius1.r",
#				"default": 0.5,
#				"label": "Radius",
#				"longdesc": "The radius of the circle",
#				"max": 1,
#				"min": 0,
#				"name": "r",
#				"shortdesc": "Radius",
#				"step": 0.01,
#				"type": "float"
#			},
#			{
#				"control": "P1.x",
#				"default": 0,
#				"label": "Center X",
#				"longdesc": "The position of the center on the X axis",
#				"max": 1,
#				"min": -1,
#				"name": "cx",
#				"shortdesc": "Center.x",
#				"step": 0.01,
#				"type": "float"
#			},
#			{
#				"control": "P1.y",
#				"default": 0,
#				"label": "Center Y",
#				"longdesc": "The position of the center on the Y axis",
#				"max": 1,
#				"min": -1,
#				"name": "cy",
#				"shortdesc": "Center.y",
#				"step": 0.01,
#				"type": "float"
#			}
#		],

#----------------------
#sdcirclerepeat.mmg
#Repeats its input shape around a circle

#Output:
#Out, sdf2d (float) (property)
#$in(circle_repeat_transform_2d($uv-vec2(0.5), $c)+vec2(0.5))

#Input:
#in, float (sdf2d), default : 0
#count, int, min: 1, max: 32, default: 6

#----------------------
#sdelongation.mmg

#		"inputs": [
#			{
#				"default": "0.0",
#				"label": "",
#				"name": "in",
#				"type": "sdf2d"
#			}
#		],
#		"outputs": [
#			{
#				"sdf2d": "$in($uv-clamp($uv-vec2(0.5), -vec2($x, $y), vec2($x, $y)))",
#				"type": "sdf2d"
#			}
#		],
#		"parameters": [
#			{
#				"control": "Rect1.x",
#				"default": 0,
#				"label": "X",
#				"max": 1,
#				"min": 0,
#				"name": "x",
#				"step": 0.01,
#				"type": "float"
#			},
#			{
#				"control": "Rect1.y",
#				"default": 0,
#				"label": "Y",
#				"max": 1,
#				"min": 0,
#				"name": "y",
#				"step": 0.01,
#				"type": "float"
#			}
#		]

#----------------------
#sdline.mmg
#A line or a capsule shape described as a signed distance function

#vec2 $(name_uv)_sdl = sdLine($uv, vec2($ax+0.5, $ay+0.5), vec2($bx+0.5, $by+0.5));

#Outputs
#output, sdf2d (float), (output property)
#$(name_uv)_sdl.x-$r*$profile($(name_uv)_sdl.y)

#Inputs
#A, Vector2, min: -1, max: 1, step: 0.01, default: (-0.3, -0.3)
#B, Vector2, min: -1, max: 1, step: 0.01, default: (0.3, 0.3)
#width, float, min: 0, max: 1, step: 0.01, default: 0.1
#points (curve), default: 0, 0, 0, 1,  0, 0, 1, 1

#----------------------
#sdmorph.mmg
#Morphs between 2 input shapes

#		"inputs": [
#			{
#				"default": "0.0",
#				"label": "",
#				"longdesc": "The first shape, defined as a signed distance function",
#				"name": "in1",
#				"shortdesc": "Input1",
#				"type": "sdf2d"
#			},
#			{
#				"default": "0.0",
#				"label": "",
#				"longdesc": "The second shape, defined as a signed distance function",
#				"name": "in2",
#				"shortdesc": "Input2",
#				"type": "sdf2d"
#			}
#		],
#		"outputs": [
#			{
#				"longdesc": "The generated hybrid shape",
#				"sdf2d": "mix($in1($uv), $in2($uv), $amount)",
#				"shortdesc": "Output",
#				"type": "sdf2d"
#			}
#		],
#		"parameters": [
#			{
#				"control": "None",
#				"default": 0.5,
#				"label": "",
#				"longdesc": "The amount of the second input in the result",
#				"max": 1,
#				"min": 0,
#				"name": "amount",
#				"shortdesc": "Amount",
#				"step": 0.01,
#				"type": "float"
#			}
#		],

#----------------------
#sdngon.mmg (inc sdrotate.mmg, sdcirclerepeat.mmg)
#An n-gon described as a signed distance function

#		"outputs": [
#			{
#				"longdesc": "The n-gon as a signed distance function",
#				"sdf2d": "sdNgon(sdf2d_rotate($uv-vec2($cx, $cy), $rot*0.01745329251-1.57079632679)-vec2(0.5), $r, $n)",
#				"shortdesc": "Output",
#				"type": "sdf2d"
#			}
#		],
#		"parameters": [
#			{
#				"control": "None",
#				"default": 3,
#				"label": "N",
#				"longdesc": "The number of sides of the n-gon",
#				"max": 12,
#				"min": 3,
#				"name": "n",
#				"shortdesc": "N",
#				"step": 1,
#				"type": "float"
#			},
#			{
#				"control": "Radius1.r",
#				"default": 0.5,
#				"label": "Radius",
#				"longdesc": "The radius of the n-gon",
#				"max": 1,
#				"min": 0,
#				"name": "r",
#				"shortdesc": "Radius",
#				"step": 0.01,
#				"type": "float"
#			},
#			{
#				"control": "Radius1.a",
#				"default": 0,
#				"label": "Rotation",
#				"longdesc": "The rotation of the n-gon",
#				"max": 180,
#				"min": -180,
#				"name": "rot",
#				"shortdesc": "Rotation",
#				"step": 0.01,
#				"type": "float"
#			},
#			{
#				"control": "P1.x",
#				"default": 0,
#				"label": "Center X",
#				"longdesc": "The position of the center on the X axis",
#				"max": 0.5,
#				"min": -0.5,
#				"name": "cx",
#				"shortdesc": "Center.x",
#				"step": 0.01,
#				"type": "float"
#			},
#			{
#				"control": "P1.y",
#				"default": 0,
#				"label": "Center Y",
#				"longdesc": "The position of the center on the Y axis",
#				"max": 0.5,
#				"min": -0.5,
#				"name": "cy",
#				"shortdesc": "Center.y",
#				"step": 0.01,
#				"type": "float"
#			}
#		],

#----------------------
#sdpolygon.mmg
#A polygon as a signed distance function

#Output:
#Out, sdf2d (float) (property)
#sdPolygon_$(name)($uv)

#Input:
#polygon points, default: 0.2, 0.2,  0.4, 0.7,  0.7, 0.4

#----------------------
#sdrepeat.mmg
#Repeats its input shape on a grid.This node does not support overlapping between instances.

#Output:
#Out, sdf2d (float) (property)
#$in(repeat_2d($uv, vec2(1.0/$rx, 1.0/$ry), float($seed), $r))

#Input:
#in, float (sdf2d), default : 0
#x, int, min: 1, max: 32, default: 4
#y, int, min: 1, max: 32, default: 4
#random_rotation, min: 0, max: 1, step:0.01, default: 0.5

#----------------------
#sdrhombus.mmg
#A rhombus described as a signed distance function

#		"outputs": [
#			{
#				"longdesc": "The rhombus as a signed distance function",
#				"sdf2d": "sdRhombus($uv-vec2($cx+0.5, $cy+0.5), vec2($w, $h))",
#				"shortdesc": "Output",
#				"type": "sdf2d"
#			}
#		],
#		"parameters": [
#			{
#				"control": "Rect1.x",
#				"default": 0.5,
#				"label": "Width",
#				"longdesc": "The width of the rhombus",
#				"max": 1,
#				"min": 0,
#				"name": "w",
#				"shortdesc": "Width",
#				"step": 0.01,
#				"type": "float"
#			},
#			{
#				"control": "Rect1.y",
#				"default": 1,
#				"label": "Height",
#				"longdesc": "The height of the rhombus",
#				"max": 1,
#				"min": 0,
#				"name": "h",
#				"shortdesc": "Height",
#				"step": 0.01,
#				"type": "float"
#			},
#			{
#				"control": "P1.x",
#				"default": 0,
#				"label": "Center X",
#				"longdesc": "The position of the center on the X axis",
#				"max": 1,
#				"min": -1,
#				"name": "cx",
#				"shortdesc": "Center.x",
#				"step": 0.01,
#				"type": "float"
#			},
#			{
#				"control": "P1.y",
#				"default": 0,
#				"label": "Center Y",
#				"longdesc": "The position of the center on the Y axis",
#				"max": 1,
#				"min": -1,
#				"name": "cy",
#				"shortdesc": "Center.y",
#				"step": 0.01,
#				"type": "float"
#			}
#		],

#----------------------
#sdrotate.mmg
#Rotates its input shape described as a signed distance function

#		"inputs": [
#			{
#				"default": "0.0",
#				"label": "",
#				"longdesc": "The input shape, defined as a signed distance function",
#				"name": "in",
#				"shortdesc": "Input",
#				"type": "sdf2d"
#			}
#		],
#		"outputs": [
#			{
#				"longdesc": "The rotated shape",
#				"sdf2d": "$in(sdf2d_rotate($uv, $a*0.01745329251))",
#				"shortdesc": "Output",
#				"type": "sdf2d"
#			}
#		],
#		"parameters": [
#			{
#				"control": "Radius1.a",
#				"default": 0,
#				"label": "",
#				"longdesc": "The rotation angle",
#				"max": 180,
#				"min": -180,
#				"name": "a",
#				"shortdesc": "Angle",
#				"step": 1,
#				"type": "float"
#			}
#		],

#----------------------
#sdroundedshape.mmg
#Dilates an input shape into a rounded shape

#Output:
#Out, sdf2d (float) (property)
#$in($uv)-$r

#Input:
#in, float (sdf2d), default : 0
#radius, min: 0, max: 1, step:0.01, default: 0

#----------------------
#sdscale.mmg
#Scales its input shape described as a signed distance function

#		"inputs": [
#			{
#				"default": "0.0",
#				"label": "",
#				"longdesc": "The input shape, defined as a signed distance function",
#				"name": "in",
#				"shortdesc": "Input",
#				"type": "sdf2d"
#			}
#		],
#		"outputs": [
#			{
#				"longdesc": "The generated scaled shape",
#				"sdf2d": "$in(($uv-vec2(0.5))/$s+vec2(0.5))*$s",
#				"shortdesc": "Output",
#				"type": "sdf2d"
#			}
#		],
#		"parameters": [
#			{
#				"control": "Scale1.x",
#				"default": 1,
#				"label": "",
#				"longdesc": "The scale of the transform",
#				"max": 5,
#				"min": 0,
#				"name": "s",
#				"shortdesc": "Scale",
#				"step": 0.01,
#				"type": "float"
#			}
#		],

#----------------------
#sdshow.mmg
#Creates a greyscale image from a shape described as a 2D Signed Distance Function

#Output

#Output float (color) - Shows the shape as a greyscale image
#clamp($base-$in($uv)/max($bevel, 0.00001), 0.0, 1.0)

#Input:
#Input (sdf - shape), default: 0 - sdf2d - universal input
#bevel, float, min 0, max 1, step 0.01, default 0
#base, float, min 0, max 1, step 0.01, default 0

#----------------------
#sdsmoothboolean.mmg
#Performs a smooth boolean operation (union, intersection or difference) between two shapes

#		"inputs": [
#			{
#				"default": "0.0",
#				"label": "",
#				"longdesc": "The first shape, defined as a signed distance function",
#				"name": "in1",
#				"shortdesc": "Input1",
#				"type": "sdf2d"
#			},
#			{
#				"default": "0.0",
#				"label": "",
#				"longdesc": "The second shape, defined as a signed distance function",
#				"name": "in2",
#				"shortdesc": "Input2",
#				"type": "sdf2d"
#			}
#		],
#		"outputs": [
#			{
#				"longdesc": "The shape generated by the boolean operation",
#				"sdf2d": "sdSmooth$op($in1($uv), $in2($uv), $k)",
#				"shortdesc": "Output",
#				"type": "sdf2d"
#			}
#		],
#		"parameters": [
#			{
#				"default": 0,
#				"label": "",
#				"longdesc": "The operation performed by this node",
#				"name": "op",
#				"shortdesc": "Operation",
#				"type": "enum",
#				"values": [
#					{
#						"name": "Union",
#						"value": "Union"
#					},
#					{
#						"name": "Subtraction",
#						"value": "Subtraction"
#					},
#					{
#						"name": "Intersection",
#						"value": "Intersection"
#					}
#				]
#			},
#			{
#				"control": "None",
#				"default": 0,
#				"label": "",
#				"longdesc": "The smoothness of the boolean operation",
#				"max": 1,
#				"min": 0,
#				"name": "k",
#				"shortdesc": "Smoothness",
#				"step": 0.01,
#				"type": "float"
#			}
#		],

#----------------------
#sdtranslate.mmg
#Translates its input shape described as signed distance function

#		"inputs": [
#			{
#				"default": "0.0",
#				"label": "",
#				"longdesc": "The input shape, defined as a signed distance function",
#				"name": "in",
#				"shortdesc": "Input",
#				"type": "sdf2d"
#			}
#		],
#		"outputs": [
#			{
#				"longdesc": "The translated shape",
#				"sdf2d": "$in($uv-vec2($x, $y))",
#				"shortdesc": "Output",
#				"type": "sdf2d"
#			}
#		],
#		"parameters": [
#			{
#				"control": "P1.x",
#				"default": 0,
#				"label": "X",
#				"longdesc": "The translation along the X axis",
#				"max": 1,
#				"min": -1,
#				"name": "x",
#				"shortdesc": "Translate.x",
#				"step": 0.01,
#				"type": "float"
#			},
#			{
#				"control": "P1.y",
#				"default": 0,
#				"label": "Y",
#				"longdesc": "The translation along the Y axis",
#				"max": 1,
#				"min": -1,
#				"name": "y",
#				"shortdesc": "Translate.y",
#				"step": 0.01,
#				"type": "float"
#			}
#		],

#----------------------
#curve.mmg

#		"code": "vec2 $(name_uv)_bezier = sdBezier($uv, vec2($ax+0.5, $ay+0.5), vec2($bx+0.5, $by+0.5), vec2($cx+0.5, $cy+0.5));\nvec2 $(name_uv)_uv = vec2($(name_uv)_bezier.x, $(name_uv)_bezier.y/$width+0.5);\nvec2 $(name_uv)_uvtest = step(vec2(0.5), abs($(name_uv)_uv-vec2(0.5)));\n$(name_uv)_uv = mix(vec2(fract($repeat*$(name_uv)_uv.x), $(name_uv)_uv.y), vec2(0.0), max($(name_uv)_uvtest.x, $(name_uv)_uvtest.y));\n",
#		"inputs": [
#			{
#				"default": "vec4(vec3(step(abs($uv.y-0.5), 0.4999)), 1.0)",
#				"label": "",
#				"longdesc": "Input pattern to be drawn along the curve",
#				"name": "in",
#				"shortdesc": "Pattern",
#				"type": "rgba"
#			}
#		],
#		"outputs": [
#			{
#				"longdesc": "An image showing the specified curve",
#				"rgba": "$in($(name_uv)_uv)",
#				"shortdesc": "Output",
#				"type": "rgba"
#			}
#		],
#		"parameters": [
#			{
#				"control": "P1.x",
#				"default": -0.3,
#				"label": "AX",
#				"longdesc": "Position on X axis of the first control point",
#				"max": 0.5,
#				"min": -0.5,
#				"name": "ax",
#				"shortdesc": "A.x",
#				"step": 0.01,
#				"type": "float"
#			},
#			{
#				"control": "P1.y",
#				"default": -0.1,
#				"label": "AY",
#				"longdesc": "Position on Y axis of the first control point",
#				"max": 0.5,
#				"min": -0.5,
#				"name": "ay",
#				"shortdesc": "A.y",
#				"step": 0.01,
#				"type": "float"
#			},
#			{
#				"control": "P3.x",
#				"default": -0,
#				"label": "BX",
#				"longdesc": "Position on X axis of the second control point",
#				"max": 0.5,
#				"min": -0.5,
#				"name": "bx",
#				"shortdesc": "B.x",
#				"step": 0.01,
#				"type": "float"
#			},
#			{
#				"control": "P3.y",
#				"default": 0.2,
#				"label": "BY",
#				"longdesc": "Position on Y axis of the second control point",
#				"max": 0.5,
#				"min": -0.5,
#				"name": "by",
#				"shortdesc": "B.y",
#				"step": 0.01,
#				"type": "float"
#			},
#			{
#				"control": "P2.x",
#				"default": 0.3,
#				"label": "CX",
#				"longdesc": "Position on X axis of the third control point",
#				"max": 0.5,
#				"min": -0.5,
#				"name": "cx",
#				"shortdesc": "C.x",
#				"step": 0.01,
#				"type": "float"
#			},
#			{
#				"control": "P2.y",
#				"default": -0.1,
#				"label": "CY",
#				"longdesc": "Position on Y axis of the third control point",
#				"max": 0.5,
#				"min": -0.5,
#				"name": "cy",
#				"shortdesc": "C.y",
#				"step": 0.01,
#				"type": "float"
#			},
#			{
#				"control": "None",
#				"default": 0.1,
#				"label": "Width",
#				"longdesc": "Width of the curve pattern",
#				"max": 0.5,
#				"min": 0,
#				"name": "width",
#				"shortdesc": "Width",
#				"step": 0.01,
#				"type": "float"
#			},
#			{
#				"control": "None",
#				"default": 1,
#				"label": "Repeat",
#				"longdesc": "Number of repetitions of the input pattern",
#				"max": 16,
#				"min": 1,
#				"name": "repeat",
#				"shortdesc": "Repeat",
#				"step": 1,
#				"type": "float"
#			}
#		]

#----------------------
#sdannularshape.mmg
#Creates an annular shape from a shape described as a signed distance function

#Output

#Output float (color) - Shows the shape as a greyscale image
#sdRipples($in($uv), $r, int($ripples))

#Input:
#Input (sdf - shape), default: 0 - sdf2d - universal input
#width, float, min 0, max 1, step 0.01, default 0
#rippples, int, min 1, max 16, default 1

#----------------------
#sd_mask_to_sdf.mmg

#{
#	"connections": [
#		{
#			"from": "6520",
#			"from_port": 0,
#			"to": "gen_outputs",
#			"to_port": 0
#		},
#		{
#			"from": "edge_detect",
#			"from_port": 0,
#			"to": "1823",
#			"to_port": 0
#		},
#		{
#			"from": "gen_inputs",
#			"from_port": 0,
#			"to": "buffer_2",
#			"to_port": 0
#		},
#		{
#			"from": "buffer_2",
#			"from_port": 0,
#			"to": "6520",
#			"to_port": 1
#		},
#		{
#			"from": "buffer_2",
#			"from_port": 0,
#			"to": "tones_step",
#			"to_port": 0
#		},
#		{
#			"from": "tones_step",
#			"from_port": 0,
#			"to": "edge_detect",
#			"to_port": 0
#		},
#		{
#			"from": "1823",
#			"from_port": 0,
#			"to": "iterate_buffer",
#			"to_port": 0
#		},
#		{
#			"from": "2434_8",
#			"from_port": 0,
#			"to": "iterate_buffer",
#			"to_port": 1
#		},
#		{
#			"from": "iterate_buffer",
#			"from_port": 0,
#			"to": "6520",
#			"to_port": 0
#		},
#		{
#			"from": "24282_2",
#			"from_port": 0,
#			"to": "2434_8",
#			"to_port": 0
#		},
#		{
#			"from": "iterate_buffer",
#			"from_port": 1,
#			"to": "24282_2",
#			"to_port": 0
#		}
#	],
#	"label": "Mask to SDF",
#	"longdesc": "",
#	"name": "sd_mask_to_sdf",
#	"node_position": {
#		"x": 0,
#		"y": 0
#	},
#	"nodes": [
#		{
#			"name": "iterate_buffer",
#			"node_position": {
#				"x": 76.700005,
#				"y": -249.817047
#			},
#			"parameters": {
#				"filter": false,
#				"iterations": 30,
#				"mipmap": false,
#				"size": 10
#			},
#			"seed_value": 29168,
#			"type": "iterate_buffer"
#		},
#		{
#			"name": "2434_8",
#			"node_position": {
#				"x": 91.099991,
#				"y": -9.031479
#			},
#			"parameters": {
#				"distance": 0,
#				"size": 10
#			},
#			"shader_model": {
#				"code": "",
#				"global": "",
#				"inputs": [
#					{
#						"default": "vec3(-1.0)",
#						"function": true,
#						"label": "",
#						"name": "in",
#						"type": "rgb"
#					}
#				],
#				"instance": "vec3 $(name)_jump_flood(vec2 uv, float size) {\n\tivec2 int_uv = ivec2(uv * size);\n\tfloat best_distance = 9999.9;\n\tvec2 best_coord;\n\tfloat iter = $in(uv).b;\n\titer += 0.01;\n\tfloat step_width = size / 4.0 / (iter * 100.0);\n\t\n\tfor (int x = -1; x <= 1; x++) {\n\t\tfor (int y = -1; y <= 1; y++) {\n\t\t\tivec2 offsetUV = int_uv + ivec2(x, y) * int(step_width);\n\t\t\tvec2 float_uv = vec2(offsetUV) / size;\n\t\t\tvec2 offset_pos = $in(float_uv).rg;\n\t\t\t\n\t\t\tif (offset_pos.x != 0.0 && offset_pos.y != 0.0) {\n\t\t\t\tvec2 diff = offset_pos - uv;\n\t\t\t\t//float dist = dot(diff, diff);\n\t\t\t\t$distance\n\t\t\t\tif (dist < best_distance) {\n\t\t\t\t\tbest_distance = dist;\n\t\t\t\t\tbest_coord = offset_pos;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn vec3(best_coord, iter);\n}",
#				"name": "Jump Flood",
#				"outputs": [
#					{
#						"rgb": "$(name)_jump_flood($uv, $size)",
#						"type": "rgb"
#					}
#				],
#				"parameters": [
#					{
#						"default": 10,
#						"first": 0,
#						"label": "",
#						"last": 13,
#						"name": "size",
#						"type": "size"
#					},
#					{
#						"default": 0,
#						"label": "",
#						"name": "distance",
#						"type": "enum",
#						"values": [
#							{
#								"name": "Euclidean",
#								"value": "float dist = dot(diff, diff);"
#							},
#							{
#								"name": "Manhattan",
#								"value": "float dist = abs(diff.x) + abs(diff.y);"
#							},
#							{
#								"name": "Chebyshev",
#								"value": "float dist = abs(diff.x) > abs(diff.y) ? abs(diff.x) : abs(diff.y);"
#							}
#						]
#					}
#				]
#			},
#			"type": "shader"
#		},
#		{
#			"name": "1823",
#			"node_position": {
#				"x": -269.899872,
#				"y": -18.741766
#			},
#			"parameters": {
#
#			},
#			"shader_model": {
#				"code": "",
#				"global": "",
#				"inputs": [
#					{
#						"default": "1.0",
#						"label": "",
#						"name": "in",
#						"type": "f"
#					}
#				],
#				"instance": "",
#				"name": "Mask to UV Mask",
#				"outputs": [
#					{
#						"rgb": "$in($uv) < .5 ? vec3(0.0) : vec3($uv, 0.0)",
#						"type": "rgb"
#					}
#				],
#				"parameters": [
#
#				]
#			},
#			"type": "shader"
#		},
#		{
#			"name": "edge_detect",
#			"node_position": {
#				"x": -286.951447,
#				"y": -137.078964
#			},
#			"parameters": {
#				"size": 10,
#				"threshold": 0.4,
#				"width": 1
#			},
#			"type": "edge_detect"
#		},
#		{
#			"name": "6520",
#			"node_position": {
#				"x": 364.156525,
#				"y": -261.873169
#			},
#			"parameters": {
#				"distance": 0,
#				"tiled": false
#			},
#			"shader_model": {
#				"code": "",
#				"global": "",
#				"inputs": [
#					{
#						"default": "vec3(0.0)",
#						"function": true,
#						"label": "",
#						"name": "in",
#						"type": "rgb"
#					},
#					{
#						"default": "0.0",
#						"function": true,
#						"label": "",
#						"name": "mask",
#						"type": "f"
#					}
#				],
#				"instance": "float $(name)_distance(vec2 uv, bool tiled) {\n\tif (tiled) {\n\t\tuv = fract(uv);\n\t}\n\tvec2 custom_uv = $in(uv).xy;\n\tvec2 diff = custom_uv != vec2(0.0) ? custom_uv - uv : vec2(1.0);\n\t$distance\n\tif (!tiled) {\n\t\tuv = clamp(uv, 0.0, 1.0);\n\t}\n\treturn $mask(uv) < 0.5 ? distance : -distance;\n}",
#				"name": "Calculate Distance",
#				"outputs": [
#					{
#						"sdf2d": "$(name)_distance($uv, $tiled)",
#						"type": "sdf2d"
#					}
#				],
#				"parameters": [
#					{
#						"default": false,
#						"label": "Tiled",
#						"name": "tiled",
#						"type": "boolean"
#					},
#					{
#						"default": 0,
#						"label": "",
#						"name": "distance",
#						"type": "enum",
#						"values": [
#							{
#								"name": "Euclidean",
#								"value": "float distance = length(diff);"
#							},
#							{
#								"name": "Manhattan",
#								"value": "float distance = abs(diff.x) + abs(diff.y);"
#							},
#							{
#								"name": "Chebyshev",
#								"value": "float distance = abs(diff.x) > abs(diff.y) ? abs(diff.x) : abs(diff.y);"
#							}
#						]
#					}
#				]
#			},
#			"type": "shader"
#		},
#		{
#			"name": "gen_inputs",
#			"node_position": {
#				"x": -735.85144,
#				"y": -352.006775
#			},
#			"parameters": {
#
#			},
#			"ports": [
#				{
#					"group_size": 0,
#					"longdesc": "The greyscale mask to be converted",
#					"name": "mask",
#					"shortdesc": "Mask",
#					"type": "f"
#				}
#			],
#			"type": "ios"
#		},
#		{
#			"name": "gen_outputs",
#			"node_position": {
#				"x": 646.256348,
#				"y": -263.285461
#			},
#			"parameters": {
#
#			},
#			"ports": [
#				{
#					"group_size": 0,
#					"longdesc": "The genrated distance field",
#					"name": "sdf",
#					"shortdesc": "Output",
#					"type": "sdf2d"
#				}
#			],
#			"type": "ios"
#		},
#		{
#			"name": "gen_parameters",
#			"node_position": {
#				"x": -47.67952,
#				"y": -541.979187
#			},
#			"parameters": {
#				"param0": 10,
#				"param1": 30,
#				"param2": false,
#				"param3": 0
#			},
#			"type": "remote",
#			"widgets": [
#				{
#					"label": "Size",
#					"linked_widgets": [
#						{
#							"node": "iterate_buffer",
#							"widget": "size"
#						},
#						{
#							"node": "2434_8",
#							"widget": "size"
#						},
#						{
#							"node": "buffer_2",
#							"widget": "size"
#						},
#						{
#							"node": "edge_detect",
#							"widget": "size"
#						}
#					],
#					"longdesc": "The resolution used for the operation",
#					"name": "param0",
#					"shortdesc": "Size",
#					"type": "linked_control"
#				},
#				{
#					"label": "Iterations",
#					"linked_widgets": [
#						{
#							"node": "iterate_buffer",
#							"widget": "iterations"
#						}
#					],
#					"longdesc": "The number of iterations the jump flood algorithm performs to calculate the distances",
#					"name": "param1",
#					"shortdesc": "Iterations",
#					"type": "linked_control"
#				},
#				{
#					"label": "Tiled",
#					"linked_widgets": [
#						{
#							"node": "24282_2",
#							"widget": "tiled"
#						},
#						{
#							"node": "6520",
#							"widget": "tiled"
#						}
#					],
#					"longdesc": "Controls whether the resulting ditance field will be tiled. Useful for patterns that extend over the texture bounds",
#					"name": "param2",
#					"shortdesc": "Tiled",
#					"type": "linked_control"
#				},
#				{
#					"label": "Distance",
#					"linked_widgets": [
#						{
#							"node": "2434_8",
#							"widget": "distance"
#						},
#						{
#							"node": "6520",
#							"widget": "distance"
#						}
#					],
#					"name": "param3",
#					"shortdesc": "Distance function",
#					"type": "linked_control"
#				}
#			]
#		},
#		{
#			"name": "buffer_2",
#			"node_position": {
#				"x": -297.702789,
#				"y": -348.41391
#			},
#			"parameters": {
#				"size": 10
#			},
#			"type": "buffer",
#			"version": 1
#		},
#		{
#			"name": "tones_step",
#			"node_position": {
#				"x": -294.947968,
#				"y": -258.84549
#			},
#			"parameters": {
#				"invert": false,
#				"value": 0.5,
#				"width": 0
#			},
#			"type": "tones_step"
#		},
#		{
#			"name": "24282_2",
#			"node_position": {
#				"x": 114.391708,
#				"y": -90.765732
#			},
#			"parameters": {
#				"tiled": false
#			},
#			"shader_model": {
#				"code": "vec3 $(name_uv)_in = $in(fract($uv));\nvec3 $(name_uv)_tiled = $(name_uv)_in.xy != vec2(0.0) ? $(name_uv)_in + vec3(floor($uv), 0.0) : $(name_uv)_in;",
#				"global": "",
#				"inputs": [
#					{
#						"default": "vec3(1.0)",
#						"function": true,
#						"label": "",
#						"name": "in",
#						"type": "rgb"
#					}
#				],
#				"instance": "",
#				"name": "Tiling",
#				"outputs": [
#					{
#						"rgb": "$tiled ? $(name_uv)_tiled : $(name_uv)_in",
#						"type": "rgb"
#					}
#				],
#				"parameters": [
#					{
#						"default": false,
#						"label": "Tiled",
#						"name": "tiled",
#						"type": "boolean"
#					}
#				]
#			},
#			"type": "shader"
#		},
#		{
#			"connections": [
#				{
#					"from": "edge_detect",
#					"from_port": 0,
#					"to": "1823",
#					"to_port": 0
#				},
#				{
#					"from": "tones_step",
#					"from_port": 0,
#					"to": "edge_detect",
#					"to_port": 0
#				},
#				{
#					"from": "1823",
#					"from_port": 0,
#					"to": "iterate_buffer",
#					"to_port": 0
#				},
#				{
#					"from": "2434_8",
#					"from_port": 0,
#					"to": "iterate_buffer",
#					"to_port": 1
#				},
#				{
#					"from": "iterate_buffer",
#					"from_port": 0,
#					"to": "6520",
#					"to_port": 0
#				},
#				{
#					"from": "24282_2",
#					"from_port": 0,
#					"to": "2434_8",
#					"to_port": 0
#				},
#				{
#					"from": "iterate_buffer",
#					"from_port": 1,
#					"to": "24282_2",
#					"to_port": 0
#				},
#				{
#					"from": "iterate_buffer",
#					"from_port": 0,
#					"to": "2153",
#					"to_port": 1
#				},
#				{
#					"from": "buffer_2",
#					"from_port": 0,
#					"to": "tones_step",
#					"to_port": 0
#				},
#				{
#					"from": "gen_inputs",
#					"from_port": 1,
#					"to": "2153",
#					"to_port": 0
#				},
#				{
#					"from": "2153",
#					"from_port": 0,
#					"to": "11582",
#					"to_port": 1
#				},
#				{
#					"from": "gen_inputs",
#					"from_port": 1,
#					"to": "11582",
#					"to_port": 2
#				},
#				{
#					"from": "11582",
#					"from_port": 0,
#					"to": "gen_outputs",
#					"to_port": 0
#				},
#				{
#					"from": "8064",
#					"from_port": 0,
#					"to": "2153",
#					"to_port": 2
#				},
#				{
#					"from": "gen_inputs",
#					"from_port": 0,
#					"to": "8064",
#					"to_port": 0
#				},
#				{
#					"from": "8064",
#					"from_port": 0,
#					"to": "buffer_2",
#					"to_port": 0
#				},
#				{
#					"from": "buffer_2",
#					"from_port": 0,
#					"to": "6520",
#					"to_port": 1
#				},
#				{
#					"from": "6520",
#					"from_port": 0,
#					"to": "11582",
#					"to_port": 0
#				}
#			],
#			"label": "Dilate 2",
#			"longdesc": "",
#			"name": "graph_3",
#			"node_position": {
#				"x": 515.555786,
#				"y": -545.049744
#			},
#			"nodes": [
#				{
#					"name": "iterate_buffer",
#					"node_position": {
#						"x": 64.900002,
#						"y": -259.215881
#					},
#					"parameters": {
#						"filter": false,
#						"iterations": 30,
#						"mipmap": false,
#						"size": 9
#					},
#					"seed_value": 29168,
#					"type": "iterate_buffer"
#				},
#				{
#					"name": "2434_8",
#					"node_position": {
#						"x": 102.099998,
#						"y": 15.367363
#					},
#					"parameters": {
#						"distance": 0,
#						"size": 9
#					},
#					"shader_model": {
#						"code": "",
#						"global": "",
#						"inputs": [
#							{
#								"default": "vec3(-1.0)",
#								"function": true,
#								"label": "",
#								"name": "in",
#								"type": "rgb"
#							}
#						],
#						"instance": "vec3 $(name)_jump_flood(vec2 uv, float size) {\n\tivec2 int_uv = ivec2(uv * size);\n\tfloat best_distance = 9999.9;\n\tvec2 best_coord;\n\tfloat iter = $in(uv).b;\n\titer += 0.01;\n\tfloat step_width = size / 4.0 / (iter * 100.0);\n\t\n\tfor (int x = -1; x <= 1; x++) {\n\t\tfor (int y = -1; y <= 1; y++) {\n\t\t\tivec2 offsetUV = int_uv + ivec2(x, y) * int(step_width);\n\t\t\tvec2 float_uv = vec2(offsetUV) / size;\n\t\t\tvec2 offset_pos = $in(float_uv).rg;\n\t\t\t\n\t\t\tif (offset_pos.x != 0.0 && offset_pos.y != 0.0) {\n\t\t\t\tvec2 diff = offset_pos - uv;\n\t\t\t\t//float dist = dot(diff, diff);\n\t\t\t\t//float dist = abs(diff.x) + abs(diff.y);\n\t\t\t\t//float dist = abs(diff.x) > abs(diff.y) ? abs(diff.x) : abs(diff.y);\n\t\t\t\t$distance\n\t\t\t\tif (dist < best_distance) {\n\t\t\t\t\tbest_distance = dist;\n\t\t\t\t\tbest_coord = offset_pos;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn vec3(best_coord, iter);\n}",
#						"name": "Jump Flood",
#						"outputs": [
#							{
#								"rgb": "$(name)_jump_flood($uv, $size)",
#								"type": "rgb"
#							}
#						],
#						"parameters": [
#							{
#								"default": 10,
#								"first": 0,
#								"label": "",
#								"last": 13,
#								"name": "size",
#								"type": "size"
#							},
#							{
#								"default": 2,
#								"label": "",
#								"name": "distance",
#								"type": "enum",
#								"values": [
#									{
#										"name": "Euclidean",
#										"value": "float dist = dot(diff, diff);"
#									},
#									{
#										"name": "Manhattan",
#										"value": "float dist = abs(diff.x) + abs(diff.y);"
#									},
#									{
#										"name": "Chebyshev",
#										"value": "float dist = abs(diff.x) > abs(diff.y) ? abs(diff.x) : abs(diff.y);"
#									}
#								]
#							}
#						]
#					},
#					"type": "shader"
#				},
#				{
#					"name": "1823",
#					"node_position": {
#						"x": -269.899872,
#						"y": -17.741766
#					},
#					"parameters": {
#
#					},
#					"shader_model": {
#						"code": "",
#						"global": "",
#						"inputs": [
#							{
#								"default": "1.0",
#								"label": "",
#								"name": "in",
#								"type": "f"
#							}
#						],
#						"instance": "",
#						"name": "Mask to UV Mask",
#						"outputs": [
#							{
#								"rgb": "$in($uv) < .5 ? vec3(0.0) : vec3($uv, 0.0)",
#								"type": "rgb"
#							}
#						],
#						"parameters": [
#
#						]
#					},
#					"type": "shader"
#				},
#				{
#					"name": "edge_detect",
#					"node_position": {
#						"x": -286.951447,
#						"y": -137.078964
#					},
#					"parameters": {
#						"size": 9,
#						"threshold": 0.4,
#						"width": 1
#					},
#					"type": "edge_detect"
#				},
#				{
#					"name": "6520",
#					"node_position": {
#						"x": 347.356567,
#						"y": -346.449127
#					},
#					"parameters": {
#						"distance": 0,
#						"length": 0.1
#					},
#					"shader_model": {
#						"code": "",
#						"global": "",
#						"inputs": [
#							{
#								"default": "vec3(0.0)",
#								"function": true,
#								"label": "",
#								"name": "in",
#								"type": "rgb"
#							},
#							{
#								"default": "0.0",
#								"function": true,
#								"label": "",
#								"name": "mask",
#								"type": "f"
#							}
#						],
#						"instance": "float $(name)_distance(vec2 uv, float length) {\n\tvec2 custom_uv = $in(fract(uv)).xy;\n\tvec2 diff = custom_uv != vec2(0.0) ? custom_uv - fract(uv) : vec2(1.0);\n\t//float distance = length(diff);\n\t//float distance = abs(diff.x) + abs(diff.y);\n\t//float distance = abs(diff.x) > abs(diff.y) ? abs(diff.x) : abs(diff.y);\n\t$distance\n\tif (length >= 0.0) {\n\t\treturn $mask(uv) < 0.5 ? clamp(1.0 - (distance / length), 0.0, 1.0) : 1.0;\n\t} else {\n\t\treturn $mask(uv) > 0.5 ? clamp((distance / -length), 0.0, 1.0) : 0.0;\n\t}\n}",
#						"name": "Calculate Distance",
#						"outputs": [
#							{
#								"f": "$(name)_distance($uv, $length)",
#								"type": "f"
#							}
#						],
#						"parameters": [
#							{
#								"control": "None",
#								"default": 0.1,
#								"label": "Length",
#								"max": 1,
#								"min": -1,
#								"name": "length",
#								"step": 0.01,
#								"type": "float"
#							},
#							{
#								"default": 2,
#								"label": "",
#								"name": "distance",
#								"type": "enum",
#								"values": [
#									{
#										"name": "Euclidean",
#										"value": "float distance = length(diff);"
#									},
#									{
#										"name": "Manhattan",
#										"value": "float distance = abs(diff.x) + abs(diff.y);"
#									},
#									{
#										"name": "Chebyshev",
#										"value": "float distance = abs(diff.x) > abs(diff.y) ? abs(diff.x) : abs(diff.y);"
#									}
#								]
#							}
#						]
#					},
#					"type": "shader"
#				},
#				{
#					"name": "gen_inputs",
#					"node_position": {
#						"x": -793.451477,
#						"y": -236.812195
#					},
#					"parameters": {
#
#					},
#					"ports": [
#						{
#							"group_size": 0,
#							"longdesc": "The greyscale mask to be converted",
#							"name": "mask",
#							"shortdesc": "Mask",
#							"type": "f"
#						},
#						{
#							"group_size": 0,
#							"longdesc": "",
#							"name": "source",
#							"shortdesc": "Source",
#							"type": "rgb"
#						}
#					],
#					"type": "ios"
#				},
#				{
#					"name": "gen_outputs",
#					"node_position": {
#						"x": 885.056335,
#						"y": -247.896317
#					},
#					"parameters": {
#
#					},
#					"ports": [
#						{
#							"group_size": 0,
#							"longdesc": "Shows the dilated image",
#							"name": "out",
#							"shortdesc": "Output",
#							"type": "rgb"
#						}
#					],
#					"type": "ios"
#				},
#				{
#					"name": "gen_parameters",
#					"node_position": {
#						"x": 61.520477,
#						"y": -639.339172
#					},
#					"parameters": {
#						"param0": 9,
#						"param1": 0.1,
#						"param2": 0,
#						"param3": 0,
#						"param4": 30
#					},
#					"type": "remote",
#					"widgets": [
#						{
#							"label": "",
#							"linked_widgets": [
#								{
#									"node": "iterate_buffer",
#									"widget": "size"
#								},
#								{
#									"node": "2434_8",
#									"widget": "size"
#								},
#								{
#									"node": "buffer_2",
#									"widget": "size"
#								},
#								{
#									"node": "edge_detect",
#									"widget": "size"
#								}
#							],
#							"longdesc": "The resolution of the input images",
#							"name": "param0",
#							"shortdesc": "Size",
#							"type": "linked_control"
#						},
#						{
#							"label": "",
#							"linked_widgets": [
#								{
#									"node": "6520",
#									"widget": "length"
#								}
#							],
#							"longdesc": "The length of the dilate effect",
#							"name": "param1",
#							"shortdesc": "Length",
#							"type": "linked_control"
#						},
#						{
#							"label": "",
#							"linked_widgets": [
#								{
#									"node": "11582",
#									"widget": "fill"
#								}
#							],
#							"longdesc": "0 to generate a gradient to black while dilating, 1 to fill with input color",
#							"name": "param2",
#							"shortdesc": "Fill",
#							"type": "linked_control"
#						},
#						{
#							"label": "",
#							"linked_widgets": [
#								{
#									"node": "2434_8",
#									"widget": "distance"
#								},
#								{
#									"node": "6520",
#									"widget": "distance"
#								}
#							],
#							"name": "param3",
#							"shortdesc": "Distance Function",
#							"type": "linked_control"
#						},
#						{
#							"label": "",
#							"linked_widgets": [
#								{
#									"node": "iterate_buffer",
#									"widget": "iterations"
#								}
#							],
#							"longdesc": "The number of iterations the jump flood algorithm performs to calculate the distances",
#							"name": "param4",
#							"shortdesc": "Iterations",
#							"type": "linked_control"
#						}
#					]
#				},
#				{
#					"name": "buffer_2",
#					"node_position": {
#						"x": -294.502808,
#						"y": -340.816589
#					},
#					"parameters": {
#						"size": 9
#					},
#					"type": "buffer",
#					"version": 1
#				},
#				{
#					"name": "tones_step",
#					"node_position": {
#						"x": -285.347992,
#						"y": -253.248215
#					},
#					"parameters": {
#						"invert": false,
#						"value": 0.5,
#						"width": 0
#					},
#					"type": "tones_step"
#				},
#				{
#					"name": "24282_2",
#					"node_position": {
#						"x": 109.591705,
#						"y": -88.567284
#					},
#					"parameters": {
#						"tiled": true
#					},
#					"shader_model": {
#						"code": "vec3 $(name_uv)_in = $in(fract($uv));\nvec3 $(name_uv)_tiled = $(name_uv)_in.xy != vec2(0.0) ? $(name_uv)_in + vec3(floor($uv), 0.0) : $(name_uv)_in;",
#						"global": "",
#						"inputs": [
#							{
#								"default": "vec3(1.0)",
#								"function": true,
#								"label": "",
#								"name": "in",
#								"type": "rgb"
#							}
#						],
#						"instance": "",
#						"name": "Tiling",
#						"outputs": [
#							{
#								"rgb": "$tiled ? $(name_uv)_tiled : $(name_uv)_in",
#								"type": "rgb"
#							}
#						],
#						"parameters": [
#							{
#								"default": false,
#								"label": "Tiled",
#								"name": "tiled",
#								"type": "boolean"
#							}
#						]
#					},
#					"type": "shader"
#				},
#				{
#					"name": "2153",
#					"node_position": {
#						"x": 368.85202,
#						"y": -157.100906
#					},
#					"parameters": {
#
#					},
#					"shader_model": {
#						"code": "",
#						"global": "",
#						"inputs": [
#							{
#								"default": "vec3(1.0)",
#								"label": "Source",
#								"name": "source",
#								"type": "rgb"
#							},
#							{
#								"default": "$uv",
#								"label": "Custom UV",
#								"name": "custom_uv",
#								"type": "rgb"
#							},
#							{
#								"default": "0.0",
#								"label": "Mask",
#								"name": "mask",
#								"type": "f"
#							}
#						],
#						"instance": "",
#						"name": "Dilate UV",
#						"outputs": [
#							{
#								"rgb": "$mask($uv) < 0.5 ? $source($custom_uv($uv).xy) : $source($uv)",
#								"type": "rgb"
#							}
#						],
#						"parameters": [
#
#						]
#					},
#					"type": "shader"
#				},
#				{
#					"name": "11582",
#					"node_position": {
#						"x": 609.343445,
#						"y": -239.746399
#					},
#					"parameters": {
#						"fill": 0
#					},
#					"shader_model": {
#						"code": "float $(name_uv)_dist = $distance($uv);\nvec3 $(name_uv)_color = mix($source(fract($uv)), $fill_raw(fract($uv)), float( $(name_uv)_dist != 0.0 ) );\nvec3 $(name_uv)_mix = mix($(name_uv)_color * $(name_uv)_dist, $(name_uv)_color, $fill);",
#						"global": "",
#						"inputs": [
#							{
#								"default": "0.0",
#								"function": true,
#								"label": "Distance",
#								"name": "distance",
#								"type": "f"
#							},
#							{
#								"default": "vec3(1.0)",
#								"function": true,
#								"label": "Fill Raw",
#								"name": "fill_raw",
#								"type": "rgb"
#							},
#							{
#								"default": "vec3(1.0)",
#								"function": true,
#								"label": "Source",
#								"name": "source",
#								"type": "rgb"
#							}
#						],
#						"instance": "",
#						"name": "Dilate Combine",
#						"outputs": [
#							{
#								"rgb": "$(name_uv)_mix",
#								"type": "rgb"
#							}
#						],
#						"parameters": [
#							{
#								"control": "None",
#								"default": 0,
#								"label": "Fill",
#								"max": 1,
#								"min": 0,
#								"name": "fill",
#								"step": 0.01,
#								"type": "float"
#							}
#						]
#					},
#					"type": "shader"
#				},
#				{
#					"name": "8064",
#					"node_position": {
#						"x": -282.533325,
#						"y": -433.011169
#					},
#					"parameters": {
#
#					},
#					"shader_model": {
#						"code": "",
#						"global": "",
#						"inputs": [
#							{
#								"default": "vec3(0.0)",
#								"label": "",
#								"name": "in",
#								"type": "rgb"
#							}
#						],
#						"instance": "",
#						"name": "Default Value",
#						"outputs": [
#							{
#								"rgb": "$in($uv)",
#								"type": "rgb"
#							}
#						],
#						"parameters": [
#
#						]
#					},
#					"type": "shader"
#				}
#			],
#			"parameters": {
#				"param0": 9,
#				"param1": 0.1,
#				"param2": 0,
#				"param3": 0,
#				"param4": 30
#			},
#			"shortdesc": "",
#			"type": "graph"
#		}
#	],
#	"parameters": {
#		"param0": 10,
#		"param1": 30,
#		"param2": false,
#		"param3": 0
#	},
#	"shortdesc": "",
#	"type": "graph"
#}

static func sdf_show(val : float, bevel : float) -> Color:
	var f : float = clamp(-val / max(bevel, 0.00001), 0.0, 1.0);
	
	return Color(f, f, f, 1)

static func sdf_circle(uv : Vector2, c : Vector2, r : float) -> float:
	c.x += 0.5
	c.y += 0.5
	
	return (uv - c).length() - r;

static func sdf_box(uv : Vector2, c : Vector2, wh : Vector2) -> float:
	c.x += 0.5
	c.y += 0.5
	
	var d : Vector2 = Commons.absv2(uv - c) - wh
	
	return Commons.maxv2(d, Vector2(0, 0)).length() + min(max(d.x, d.y), 0.0)

#vec2 $(name_uv)_sdl = sdLine($uv, vec2($ax+0.5, $ay+0.5), vec2($bx+0.5, $by+0.5));

static func sdf_line(uv : Vector2, a : Vector2, b : Vector2, r : float) -> Vector2:
	a.x += 0.5
	a.y += 0.5
	
	b.x += 0.5
	b.y += 0.5
	
	return sdLine(uv, a, b)


static func sdf_rhombus(uv : Vector2, c : Vector2, wh : Vector2) -> float:
	c.x += 0.5
	c.y += 0.5
	
	return sdRhombus(uv - c, wh);


static func sdf_arc(uv : Vector2, a : Vector2, r : Vector2) -> float:
	return sdArc(uv - Vector2(0.5, 0.5), Commons.modf(a.x, 360.0) * 0.01745329251, Commons.modf(a.y, 360.0)*0.01745329251, r.x, r.y)

#float sdr_ndot(vec2 a, vec2 b) { 
#	return a.x*b.x - a.y*b.y; 
#}

static func sdr_ndot(a : Vector2, b : Vector2) -> float:
	return a.x * b.x - a.y * b.y;

#float sdRhombus(in vec2 p, in vec2 b) {
#	vec2 q = abs(p);
#	float h = clamp((-2.0*sdr_ndot(q,b)+sdr_ndot(b,b))/dot(b,b),-1.0,1.0);
#	float d = length( q - 0.5*b*vec2(1.0-h,1.0+h) );
#	return d * sign( q.x*b.y + q.y*b.x - b.x*b.y );
#}

static func sdRhombus(p : Vector2, b : Vector2) -> float:
	var q : Vector2 = Commons.absv2(p);
	var h : float = clamp((-2.0 * sdr_ndot(q,b) + sdr_ndot(b,b)) / b.dot(b), -1.0, 1.0);
	var d : float = ( q - 0.5*b * Vector2(1.0-h, 1.0+h)).length()
	return d * sign(q.x*b.y + q.y*b.x - b.x*b.y)

#float sdArc(vec2 p, float a1, float a2, float ra, float rb) {
#	float amid = 0.5*(a1+a2)+1.6+3.14*step(a1, a2);
#	float alength = 0.5*(a1-a2)-1.6+3.14*step(a1, a2);
#
#	vec2 sca = vec2(cos(amid), sin(amid));
#	vec2 scb = vec2(cos(alength), sin(alength));    
#	p *= mat2(vec2(sca.x,sca.y),vec2(-sca.y,sca.x));    
#	p.x = abs(p.x);    
#
#	float k = (scb.y*p.x>scb.x*p.y) ? dot(p.xy,scb) : length(p.xy);    
#	return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;
#}

static func sdArc(p : Vector2, a1 : float, a2 : float, ra : float, rb : float) -> float:
	var amid : float = 0.5*(a1+a2)+1.6+3.14 * Commons.step(a1, a2);
	var alength : float = 0.5*(a1-a2)-1.6+3.14 * Commons.step(a1, a2);
	var sca : Vector2 = Vector2(cos(amid), sin(amid));
	var scb : Vector2 = Vector2(cos(alength), sin(alength));
	
	#p *= Matrix(Vector2(sca.x , sca.y), Vector2(-sca.y, sca.x));
	
	var pt : Vector2 = p
	
	p.x = pt.x * sca.x + pt.y * sca.y 
	p.y = pt.x * -sca.y + pt.y * sca.x
	
	p.x = abs(p.x);
	
	var k : float
	
	if (scb.y * p.x > scb.x * p.y):
		k = p.dot(scb)
	else:
		k = p.length();
	
	return sqrt( p.dot(p) + ra * ra - 2.0 * ra * k ) - rb;
	

static func sdf_boolean_union(a : float, b : float) -> float:
	return min(a, b)
	
static func sdf_boolean_substraction(a : float, b : float) -> float:
	return max(-a, b)

static func sdf_boolean_intersection(a : float, b : float) -> float:
	return max(a, b)
	
static func sdf_smooth_boolean_union(d1 : float, d2 : float, k : float) -> float:
	var h : float = clamp( 0.5 + 0.5 * (d2 - d1) / k, 0.0, 1.0)
	return lerp(d2, d1, h) - k * h * (1.0 - h)

static func sdf_smooth_boolean_substraction(d1 : float, d2 : float, k : float) -> float:
	var h : float = clamp( 0.5 - 0.5 * (d2 + d1) / k, 0.0, 1.0)
	return lerp(d2, -d1, h) + k * h * (1.0 - h)

static func sdf_smooth_boolean_intersection(d1 : float, d2 : float, k : float) -> float:
	var h : float = clamp( 0.5 - 0.5 * (d2 - d1) / k, 0.0, 1.0)
	return lerp(d2, d1, h) + k * h * (1.0 - h)

static func sdf_rounded_shape(a : float, r : float) -> float:
	return a - r

static func sdf_annular_shape(a : float, r : float) -> float:
	return abs(a) - r

static func sdf_morph(a : float, b : float, amount : float) -> float:
	return lerp(a, b, amount)

#vec2 sdLine(vec2 p, vec2 a, vec2 b) {    
#	vec2 pa = p-a, ba = b-a;    
#	float h = clamp(dot(pa,ba)/dot(ba,ba), 0.0, 1.0);    
#	return vec2(length(pa-ba*h), h);
#}

static func sdLine(p : Vector2, a  : Vector2, b : Vector2) -> Vector2:
	var pa : Vector2 = p - a
	var ba : Vector2 = b - a
	
	var h : float = clamp(pa.dot(ba) / ba.dot(ba), 0.0, 1.0);
	
	return Vector2((pa - (ba * h)).length(), h)


#Needs thought
#func sdf_translate(a : float, x : float, y : float) -> float:
#	return lerp(a, b, amount)

#vec2 sdf2d_rotate(vec2 uv, float a) {
#	vec2 rv;
#	float c = cos(a);
#	float s = sin(a);
#	uv -= vec2(0.5);
#	rv.x = uv.x*c+uv.y*s;
#	rv.y = -uv.x*s+uv.y*c;
#	return rv+vec2(0.5);
#}

static func sdf2d_rotate(uv : Vector2, a : float) -> Vector2:
	var rv : Vector2;
	var c : float = cos(a);
	var s : float = sin(a);
	uv -= Vector2(0.5, 0.5);
	rv.x = uv.x*c+uv.y*s;
	rv.y = -uv.x*s+uv.y*c;
	return rv+Vector2(0.5, 0.5);

#float cross2( in vec2 a, in vec2 b ) { 
#	return a.x*b.y - a.y*b.x; 
#}

#// signed distance to a quadratic bezier\n
#vec2 sdBezier( in vec2 pos, in vec2 A, in vec2 B, in vec2 C ) {    \n    
#	vec2 a = B - A;\n    
#	vec2 b = A - 2.0*B + C;\n    
#	vec2 c = a * 2.0;\n    
#	vec2 d = A - pos;\n\n    
#	float kk = 1.0/dot(b,b);\n    
#	float kx = kk * dot(a,b);\n    
#	float ky = kk * (2.0*dot(a,a)+dot(d,b))/3.0;\n    
#	float kz = kk * dot(d,a);      \n\n    
#	float res = 0.0;\n    
#	float sgn = 0.0;\n\n    
#	float p = ky - kx*kx;\n    
#	float p3 = p*p*p;\n    
#	float q = kx*(2.0*kx*kx - 3.0*ky) + kz;\n    
#	float h = q*q + 4.0*p3;\n\t
#	float rvx;\n\n    
#
#	if( h>=0.0 ) { 
#		// 1 root\n        
#		h = sqrt(h);\n        
#		vec2 x = (vec2(h,-h)-q)/2.0;\n       
#		vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));
#		rvx = uv.x+uv.y-kx;\n        
#		float t = clamp(rvx, 0.0, 1.0);\n        
#		vec2 q2 = d+(c+b*t)*t;\n        
#		res = dot(q2, q2);\n    \t
#		sgn = cross2(c+2.0*b*t, q2);\n    
#	} else {   
#		// 3 roots\n        
#		float z = sqrt(-p);\n        
#		float v = acos(q/(p*z*2.0))/3.0;\n        
#		float m = cos(v);\n        
#		float n = sin(v)*1.732050808;\n        
#		vec3  t = clamp(vec3(m+m,-n-m,n-m)*z-kx, 0.0, 1.0);\n        
#		vec2  qx=d+(c+b*t.x)*t.x; 
#		float dx=dot(qx, qx), sx = cross2(c+2.0*b*t.x,qx);\n        
#		vec2  qy=d+(c+b*t.y)*t.y; 
#		float dy=dot(qy, qy), sy = cross2(c+2.0*b*t.y,qy);\n        
#
#		if( dx<dy ) { 
#			res=dx; sgn=sx; rvx = t.x; 
#		} else { 
#			res=dy; sgn=sy; rvx = t.y; 
#		}\n    
#	}\n    \n    
#
#	return vec2(rvx, sqrt(res)*sign(sgn));\n
#}

# signed distance to a quadratic bezier
static func sdBezier(pos : Vector2, A : Vector2, B : Vector2, C : Vector2) -> Vector2:   
	var a : Vector2 = B - A;
	var b : Vector2 = A - 2.0 * B + C;
	var c : Vector2 = a * 2.0;
	var d : Vector2 = A - pos;

	var kk : float = 1.0 / b.dot(b);
	var kx : float = kk * a.dot(b);
	var ky : float = kk * (2.0* a.dot(a) + d.dot(b)) / 3.0;
	var kz : float = kk * d.dot(a);      

	var res : float = 0.0;
	var sgn : float = 0.0;

	var p : float = ky - kx * kx;
	var p3 : float = p * p * p;
	var q : float = kx * (2.0 * kx * kx - 3.0 * ky) + kz;
	var h : float = q * q + 4.0 * p3;
	var rvx : float = 0
	
	if(h >= 0.0):
		# // 1 root
		h = sqrt(h);
		
		var x : Vector2 = (Vector2(h,-h) - Vector2(q, q)) / 2.0

		var uv : Vector2 = Commons.signv2(x) * Commons.powv2(Commons.absv2(x), Vector2(1.0/3.0, 1.0/3.0));
		
		rvx = uv.x + uv.y - kx;
		var t : float = clamp(rvx, 0.0, 1.0);
		var q2 : Vector2 = d + (c + b * t) * t;
		res = q2.dot(q2);
		
		sgn = (c + Vector2(2, 2) * b * t).cross(q2)

	else: #  // 3 roots
		var z : float = sqrt(-p);
		var v : float = acos(q / (p * z * 2.0)) / 3.0;
		var m : float = cos(v);
		var n : float = sin(v) * 1.732050808;
		
		var t : Vector3 = Commons.clampv3(Vector3(m+m, -n-m, n-m) * z - Vector3(kx, kx, kx), Vector3(), Vector3(1, 1, 1));

		var qx : Vector2 = d + (c + b * t.x) * t.x; 
		var dx : float = qx.dot(qx)
		var sx  : float = (c + Vector2(2, 2) * b * t.x).cross(qx)
		var qy : Vector2 = d + (c + b * t.y) * t.y
		var dy : float = qy.dot(qy)
		var sy : float = (c + Vector2(2, 2) * b * t.y).cross(qy)
		
		if dx<dy:
			res=dx
			sgn=sx
			rvx = t.x
		else:
			res=dy
			sgn=sy
			rvx = t.y

	return Vector2(rvx, sqrt(res) * sign(sgn))

#vec2 circle_repeat_transform_2d(vec2 p, float count) {
#	float r = 6.28/count;
#	float pa = atan(p.x, p.y);
#	float a = mod(pa+0.5*r, r)-0.5*r;
#
#	vec2 rv;
#
#	float c = cos(a-pa);
#	float s = sin(a-pa);
#
#	rv.x = p.x*c+p.y*s;
#	rv.y = -p.x*s+p.y*c;
#
#	return rv;
#}

static func circle_repeat_transform_2d(p : Vector2, count : float) -> Vector2:   
	var r : float = 6.28 / count
	var pa : float = atan2(p.x, p.y)
	var a : float = Commons.modf(pa + 0.5 * r, r)-0.5*r

	var rv : Vector2 = Vector2()

	var c : float = cos(a - pa);
	var s : float = sin(a - pa);

	rv.x = p.x * c + p.y * s
	rv.y = -p.x * s + p.y * c

	return rv;

#float sdNgon(vec2 p, float r, float n) {
#	float PI = 3.1415926535;
#	p = circle_repeat_transform_2d(p, n);
#	vec2 d = abs(p)-vec2(r*tan(3.14159265359/n), r);
#	return p.y < r ? p.y-r : length(max(d,vec2(0)))+min(max(d.x,d.y),0.0);
#}

static func sdNgon(pos : Vector2, r : float, n : float) -> Vector2:
	return Vector2()


#vec2 repeat_2d(vec2 p, vec2 r, float seed, float randomness) {
#	p -= vec2(0.5);
#	float a = (rand(floor(mod((p.xy+0.5*r.xy)/r.xy, 1.0/r.xy)+vec2(seed)))-0.5)*6.28*randomness;
#	p = mod(p+0.5*r,r)-0.5*r;
#	vec2 rv;
#	float c = cos(a);
#	float s = sin(a);
#	rv.x = p.x*c+p.y*s;
#	rv.y = -p.x*s+p.y*c;
#	return rv+vec2(0.5);
#}

static func repeat_2d(p : Vector2, r : Vector2, pseed : float, randomness : float) -> Vector2:
	p -= Vector2(0.5, 0.5);
	var v : Vector2 = Vector2(p.x, p.y) + Vector2(0.5, 0.5) + Vector2(r.x, r.y)
	var a : float = ((Commons.rand2(Commons.floorv2(Commons.modv2(v / Vector2(r.x, r.y), Vector2(1.0, 1.0) / Vector2(r.x, r.y)) + Vector2(pseed, pseed))) - Vector2(0.5, 0.5)) * 6.28 * randomness).x
	p = Commons.modv2(p + Vector2(0.5, 0.5) * r,r)- Vector2(0.5, 0.5) * r
	var rv : Vector2 = Vector2()
	var c : float = cos(a)
	var s : float = sin(a)
	rv.x = p.x * c + p.y * s
	rv.y = -p.x * s + p.y * c
	return rv + Vector2(0.5, 0.5);
	
#float sdSmoothUnion( float d1, float d2, float k ) {
#	float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );
#	return mix( d2, d1, h ) - k*h*(1.0-h); 
#}

static func sdSmoothUnion(d1 : float, d2 : float, k : float) -> float:
	return 0.0

#float sdSmoothSubtraction( float d1, float d2, float k ) {
#	float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );
#	return mix( d2, -d1, h ) + k*h*(1.0-h); 
#}

static func sdSmoothSubtraction(d1 : float, d2 : float, k : float) -> float:
	return 0.0

#float sdSmoothIntersection( float d1, float d2, float k ) {
#	float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );
#	return mix( d2, d1, h ) + k*h*(1.0-h); 
#}

static func sdSmoothIntersection(d1 : float, d2 : float, k : float) -> float:
	return 0.0
	
	
#float sdRipples(float d, float w, int r) {\n
#	for (int i = 0; i < r; ++i) {
#		d = abs(d)-w;
#	}
#
#	return d;
#}

static func sdRipples(d : float, w : float, r : int) -> float:
	for i in range(r):
		d = abs(d)-w;

	return d

#$polygon = { p1(vec2), p2(vec2), p3(vec2) ... }
#float sdPolygon_$(name)(vec2 p) {
#	vec2 v[] = $polygon;
#	int l = v.length();
#	float d = dot(p-v[0],p-v[0]);
#	float s = 1.0;
#	int j = l-1;
#
#	for(int i=0; i<l; i++) {        
#		vec2 e = v[j] - v[i];
#		vec2 w = p - v[i];
#		vec2 b = w - e*clamp( dot(w,e)/dot(e,e), 0.0, 1.0 );
#		d = min( d, dot(b,b) );
#		bvec3 c = bvec3(p.y>=v[i].y,p.y<v[j].y,e.x*w.y>e.y*w.x);
#
#		if(all(c) || all(not(c))) {
#			s *= -1.0;
#		}
#
#		j = i;    
#	}
#
#	return s*sqrt(d);
#}

static func sdPolygon(p : Vector2, v : PoolVector2Array) -> float:
	var l : int = v.size()
	var pmv0 : Vector2 = p - v[0]
	var d : float = pmv0.dot(pmv0)
	var s : float = 1.0
	var j : int = l - 1

	for i in range(l): #for(int i=0; i<l; i++)
		var e : Vector2 = v[j] - v[i]
		var w : Vector2 = p - v[i]
		var b : Vector2 = w - e * clamp(w.dot(e) / e.dot(e), 0.0, 1.0)
		d = min(d, b.dot(b))
		
		var b1 : bool = p.y >= v[i].y
		var b2 : bool = p.y < v[j].y
		var b3 : bool = e.x * w.y > e.y * w.x

		if((b1 && b2 && b3) || (!b1 && !b2 && !b3)):
			s *= -1.0

		j = i

	return s * sqrt(d)
