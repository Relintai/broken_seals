tool
extends Reference

const Commons = preload("res://addons/mat_maker_gd/nodes/common/commons.gd")

#----------------------
#sdf3d_box.mmg
#Generates a rounded box as a signed distance function

#Outputs:

#Common
#vec3 $(name_uv)_q = abs($uv) - vec3($sx, $sy, $sz);

#Output - (sdf3d) - Shows the rounded box
#length(max($(name_uv)_q,0.0))+min(max($(name_uv)_q.x,max($(name_uv)_q.y,$(name_uv)_q.z)),0.0)-$r

#Inputs:
#size, vector3, min: 0, max: 1, default:0.5, step:0.01
#size, float, min: 0, max: 1, default:0.5, step:0.01

#----------------------
#sdf3d_sphere.mmg
#Generates a sphere as a signed distance function

#Outputs:

#Output - (sdf3d) - Shows the sphere
#length($uv)-$r

#Inputs:
#radius, vector3, min: 0, max: 1, default:0.5, step:0.01

#----------------------
#sdf3d_capsule.mmg
#Generates a capsule as a signed distance function

#Outputs:

#Common
#vec3 $(name_uv)_p = $uv;
#$(name_uv)_p.$axis -= clamp($(name_uv)_p.$axis, -$l, $l);

#Output - (sdf3d) - Shows the capsule
#length($(name_uv)_p)-$r*$profile(clamp(0.5+0.5*($uv).$axis/$l, 0.0, 1.0))

#Inputs:
#axis, enum, default: 1, values: x, y, z
#length, float, min: 0, max: 1, default:0.25, step:0.01
#radius, float, min: 0, max: 1, default:0.2, step:0.01
#profile, curve, default: (ls, rs, x, z) 0, 0, 0, 1,  0, 0, 1, 1

#----------------------
#sdf3d_cone.mmg

#Outputs:

#+X: $axis = length($uv.yz),-$uv.x
#-X: $axis = length($uv.yz),$uv.x
#+Y: $axis = length($uv.xz),$uv.y
#-Y: $axis = length($uv.xz),-$uv.y
#+Z: $axis = length($uv.xy),-$uv.z
#-Z: $axis = length($uv.xy),$uv.z

#Output - (sdf3d)
#dot(vec2(cos($a*0.01745329251),sin($a*0.01745329251)),vec2($axis))

#Inputs:
#axis, enum, default:5, values: +X, -X, +Y, -Y, +Z, -Z
#angle, float, min: 0, max: 90, default:30, step:1

#----------------------
#sdf3d_repeat.mmg

#Outputs:

#Output (sdf3d)
#Output - (sdf3dc) - The shape generated by the repeat operation
#$in(repeat($uv, vec3(1.0/$rx, 1.0/$ry, 0.0), float($seed), $r))

#Inputs:
#in, vec2, default:vec2(100, 0.0), (sdf3d input)

#X, int, min: 1, max: 32, default:4, step:1
#Y, int, min: 1, max: 32, default:4, step:1
#R, float, min: 0, max: 1, default:0.5, step:0.01

#----------------------
#sdf3d_rotate.mmg

#Outputs:

#Output - (sdf3dc) - The rotated object
#$in(rotate3d($uv, -vec3($ax, $ay, $az)*0.01745329251))

#Inputs:
#in, vec2, default:vec2(100, 0.0), (sdf3d input)
#rotation, vector3, min: -180, max: 180, default:0, step:1

#----------------------
#sdf3d_cylinder.mmg

#Outputs:

#Output - (sdf3dc) - Shows the cylinder
#min(max($(name_uv)_d.x,$(name_uv)_d.y),0.0) + length(max($(name_uv)_d,0.0))

#Inputs:
#axis, enum, default: 1, values: X, Y, Z
#length, float, min: 0, max: 1, default:0.5, step:0.01
#radius, float, min: 0, max: 1, default:0.2, step:0.01

#----------------------
#sdf3d_plane.mmg
#Generates a plane that can be used to cut other shapes

#Outputs:

#X: $axis = x
#Y: $axis = y
#Z: $axis = z

#Output - (sdf3dc) - Shows the plane
#$uv.$axis

#Inputs:
#axis, enum, default: 1, values: X, Y, Z

#----------------------
#sdf3d_torus.mmg
#Generates a torus as a signed distance function

#Outputs:

#X: $axis = length($uv.yz)-$R,$uv.x
#Y: $axis = length($uv.zx)-$R,$uv.y
#Z: $axis = length($uv.xy)-$R,$uv.z
#vec2 $(name_uv)_q = vec2($axis);

#Output - (sdf3dc) - Shows the torus
#length($(name_uv)_q)-$r

#Inputs:
#axis, enum, default: 1, values: X, Y, Z
#R, float, min: 0, max: 1, default:0.5, step:0.01
#r, float, min: 0, max: 1, default:0.1, step:0.01

#----------------------
#sdf3d_boolean.mmg

#Outputs:

#Union: $op = sdf3dc_union
#Subtraction $op = sdf3dc_sub
#Intersection $op = sdf3dc_inter

#Output - (sdf3dc) - The shape generated by the boolean operation
#$op($in1($uv), $in2($uv))

#Inputs:
#axis, enum, default: 2, values: Union, Subtraction, Intersection
#in1, vec2, default:vec2(100, 0.0), (sdf3d input)
#in2, vec2, default:vec2(100, 0.0), (sdf3d input)

#----------------------
#sdf3d_circle_repeat.mmg

#Outputs:

#Output (sdf3dc) - The shape generated by the boolean operation
#$in(circle_repeat_transform($uv, $c))

#Inputs:
#count, float, min: 1, max: 32, default:5, step:1

#----------------------
#sdf3d_angle.mmg (includes sdf3d_rotate.mmg)

#Outputs:

#Shows the angleThe shape generated by the boolean operation
#$(name_uv)_d

#X: $axis = xyz
#Y: $axis = yzx
#Z: $axis = zxy

#vec3 $(name_uv)_uv = $uv.$axis;
#float $(name_uv)_rotated = rotate3d($(name_uv)_uv, vec3(($angle-180.0)*0.01745329251, 0.0, 0.0)).y;
#float $(name_uv)_d1 = max($(name_uv)_uv.y, $(name_uv)_rotated);
#float $(name_uv)_d2 = min($(name_uv)_uv.y, $(name_uv)_rotated);
#float $(name_uv)_d = (mod($angle, 360.0) < 180.0) ? $(name_uv)_d1 : $(name_uv)_d2;

#Inputs:
#axis, enum, default: 0, values: X, Y, Z
#angle, float, min: 0, max: 360, default:180, step:0.1

#----------------------
#sdf3d_color.mmg

#Outputs:

#Output - sdf3dc - The colored 3D object
#vec2($in($uv), $c)

#Inputs:
#color_index, float, min: 0, max: 1, default:0, step:0.01
#in, vec2, default:vec2(100, 0.0), (sdf3d input)

#----------------------
#sdf3d_translate.mmg

#Outputs:

#Output - sdf3dc
#$in($uv-vec3($x, $y, $z))

#Inputs:
#translation, vector3, min: -1, max: 1, default:0, step:0.01
#in, vec2, default:vec2(100, 0.0), (sdf3dc input)

#----------------------
#sdf3d_scale.mmg

#Outputs:

#vec2 $(name_uv)_in = $in(($uv)/$s);

#Output - sdf3dc
#vec2($(name_uv)_in.x*$s, $(name_uv)_in.y)

#Inputs:
#scale_factor, float, min: 0, max: 5, default:1, step:0.01
#in, vec2, default:vec2(100, 0.0), (sdf3dc input)

#----------------------
#sdf3d_rounded.mmg

#Outputs:

#vec2 $(name_uv)_v = $in($uv);

#Output - sdf3dc
#vec2($(name_uv)_v.x-$r, $(name_uv)_v.y)

#Inputs:
#radius, float, min: 0, max: 1, default:0, step:0.01
#in, vec2, default:vec2(100, 0.0), (sdf3dc input)

#----------------------
#sdf3d_revolution.mmg

#Outputs:

#vec2 $(name_uv)_q = vec2(length($uv.xy)-$d+0.5, $uv.z+0.5);

#Output - sdf3dc
#$in($(name_uv)_q)

#Inputs:
#d, float, min: 0, max: 1, default:0.25, step:0.01
#input, float, default:10.0, (sdf2d input)

#----------------------
#sdf3d_smoothboolean.mmg
#Performs a smooth boolean operation (union, intersection or difference) between two shapes

#Outputs:

#Union: $op = union
#Subtraction: $op = subtraction
#Intersection: $op = intersection

#Output - sdf3dc
#sdf3d_smooth_$op($in1($uv), $in2($uv), $k)

#Inputs:
#in1, vec2, default:vec2(100, 0.0), (sdf3d input)
#in2, vec2, default:vec2(100, 0.0), (sdf3d input)
#operation, enum, default: 1, values: Union, Subtraction, Intersection
#smoothness, float, min: 0, max: 1, default:0, step:0.01

#----------------------
#sdf3d_elongation.mmg

#Outputs:

#Output - sdf3dc
#$in($uv-clamp($uv, -abs(vec3($x, $y, $z)), abs(vec3($x, $y, $z))))

#Inputs:
#in, vec2, default:vec2(100, 0.0), (sdf3dc input)
#elongation, vector3, min: 0, max: 1, default:0, step:0.01

#----------------------
#sdf3d_extrusion.mmg

#Outputs:

#vec2 $(name_uv)_w = vec2($in($uv.xz+vec2(0.5)),abs($uv.y)-$d);

#Output - sdf3dc
#min(max($(name_uv)_w.x,$(name_uv)_w.y),0.0)+length(max($(name_uv)_w,0.0))

#Inputs:
#in, sdf2d, default:100, (input)
#length, float, min: 0, max: 1, default:0.25, step:0.01

#----------------------
#sdf3d_morph.mmg

#Outputs:

#Output - sdf3d
#mix($in1($uv), $in2($uv), $amount)

#Inputs:
#in1, vec2, default:vec2(100, 0.0), (sdf3d input)
#in2, vec2, default:vec2(100, 0.0), (sdf3d input)
#amount, float, min: 0, max: 1, default:0.5, step:0.01

#----------------------
#raymarching.mmg (raymarching_preview.mmg)
#Raymarches a 3D object (described as signed distance function with optional color index) 
#to render a heightmap, a normal map and a color index map.

#raymarch_$name = sdf3d_raymarch
#vec2 $(name_uv)_d = raymarch_$name($uv);

#Outputs:

#HeightMap - float - The generated height map
#1.0-$(name_uv)_d.x

#NormalMap - rgb - The generated normal map
#vec3(0.5)+0.5*normal_$name(vec3($uv-vec2(0.5), 1.0-$(name_uv)_d.x))

#ColorMap - float - The generated color index map
#$(name_uv)_d.y

#Inputs:
#input, vec2, default:vec2(100, 0.0), (sdf3dc input)

#----------------------
#raymarching_preview.mmg

#Outputs:

#Output (rgb)
#render_$name($uv-vec2(0.5))

#Inputs:
#input, vec2, default:vec2(100, 0.0), (sdf3dc input)

static func raymarch(uv : Vector2) -> Color:
	var d : Vector2 = sdf3d_raymarch(uv);
	
	var f : float = 1.0 - d.x;
	
	return Color(f, f, f, 1)

static func raymarch2(uv : Vector2) -> Color:
	var d : Vector2 = sdf3d_raymarch(uv);
	
	var v : Vector3 = Vector3(0.5, 0.5, 0.5) + 0.5 * sdf3d_normal(Vector3(uv.x - 0.5, uv.y - 0.5, 1.0 - d.x));
	
	return Color(v.x, v.y, v.z, 1)

static func raymarch3(uv : Vector2) -> Color:
	var v : Vector2 = sdf3d_raymarch(uv);
	
	return Color(v.y, v.y, v.y, 1)

#length($uv)-$r

static func sdf3d_sphere(p : Vector3, r : float) -> Vector2:
	var s : float = p.length() - r;

	return Vector2(s, 0.0);

#vec3 $(name_uv)_q = abs($uv) - vec3($sx, $sy, $sz);
#length(max($(name_uv)_q,0.0))+min(max($(name_uv)_q.x,max($(name_uv)_q.y,$(name_uv)_q.z)),0.0)-$r

static func sdf3d_box(p : Vector3, sx : float, sy : float, sz : float, r : float) -> Vector2:
	var v : Vector3 = Commons.absv3((p)) - Vector3(sx, sy, sz);
	var f : float = (Commons.maxv3(v,Vector3())).length() + min(max(v.x,max(v.y, v.z)),0.0) - r;

	return Vector2(f, 0.0);

#Y: $axis = length($uv.xz),$uv.y
#vec2 $(name_uv)_d = abs(vec2($axis)) - vec2($r,$l);

static func sdf3d_cylinder_y(p : Vector3, r : float, l : float) -> Vector2:
	var v : Vector2 = Commons.absv2(Vector2(Vector2(p.x, p.z).length(),(p).y)) - Vector2(r,l);
	var f : float = min(max(v.x, v.y),0.0) + Commons.maxv2(v, Vector2()).length();

	return Vector2(f, 0.0);

#X: $axis = length($uv.yz),$uv.x
#vec2 $(name_uv)_d = abs(vec2($axis)) - vec2($r,$l);

static func sdf3d_cylinder_x(p : Vector3, r : float, l : float) -> Vector2:
	var v : Vector2 = Commons.absv2(Vector2(Vector2(p.y, p.z).length(),(p).x)) - Vector2(r, l);
	var f : float = min(max(v.x, v.y),0.0) + Commons.maxv2(v, Vector2()).length();

	return Vector2(f, 0.0);

#Z: $axis = length($uv.xy),$uv.z
#vec2 $(name_uv)_d = abs(vec2($axis)) - vec2($r,$l);

static func sdf3d_cylinder_z(p : Vector3, r : float, l : float) -> Vector2:
	var v : Vector2 = Commons.absv2(Vector2(Vector2(p.x, p.y).length(),(p).z)) - Vector2(r, l);
	var f : float = min(max(v.x, v.y),0.0) + Commons.maxv2(v, Vector2()).length();

	return Vector2(f, 0.0);

#vec3 $(name_uv)_p = $uv;
#$(name_uv)_p.$axis -= clamp($(name_uv)_p.$axis, -$l, $l);
#return length($(name_uv)_p)-$r*$profile(clamp(0.5+0.5*($uv).$axis/$l, 0.0, 1.0))

static func sdf3d_capsule_y(p : Vector3, r : float, l : float) -> Vector2:
	var v : Vector3 = p;
	v.y -= clamp(v.y, -l, l);
	var f : float = v.length() - r;

	return Vector2(f, 0.0);

static func sdf3d_capsule_x(p : Vector3, r : float, l : float) -> Vector2:
	var v : Vector3 = p;
	v.x -= clamp(v.x, -l, l);
	var f : float = v.length() - r;

	return Vector2(f, 0.0);

static func sdf3d_capsule_z(p : Vector3, r : float, l : float) -> Vector2:
	var v : Vector3 = p;
	v.z -= clamp(v.z, -l, l);
	var f : float = v.length() - r;

	return Vector2(f, 0.0);

#+X: $axis = length($uv.yz),-$uv.x
#dot(vec2(cos($a*0.01745329251),sin($a*0.01745329251)),vec2($axis))

static func sdf3d_cone_px(p : Vector3, a : float) -> Vector2:
	var  f : float = Vector2(cos(a*0.01745329251),sin(a*0.01745329251)).dot(Vector2(Vector2(p.y, p.z).length(), - (p).x));

	return Vector2(f, 0.0);

#-X: $axis = length($uv.yz),$uv.x
#dot(vec2(cos($a*0.01745329251),sin($a*0.01745329251)),vec2($axis))

static func sdf3d_cone_nx(p : Vector3, a : float) -> Vector2:
	var  f : float = Vector2(cos(a*0.01745329251),sin(a*0.01745329251)).dot(Vector2(Vector2(p.y, p.z).length(),(p).x));

	return Vector2(f, 0.0);

#+Y: $axis = length($uv.xz),$uv.y
#dot(vec2(cos($a*0.01745329251),sin($a*0.01745329251)),vec2($axis))

static func sdf3d_cone_py(p : Vector3, a : float) -> Vector2:
	var  f : float = Vector2(cos(a*0.01745329251),sin(a*0.01745329251)).dot(Vector2(Vector2(p.x, p.z).length(),(p).y));

	return Vector2(f, 0.0);

#-Y: $axis = length($uv.xz),-$uv.y
#dot(vec2(cos($a*0.01745329251),sin($a*0.01745329251)),vec2($axis))

static func sdf3d_cone_ny(p : Vector3, a : float) -> Vector2:
	var  f : float = Vector2(cos(a*0.01745329251),sin(a*0.01745329251)).dot(Vector2(Vector2(p.x, p.z).length(),-(p).y));

	return Vector2(f, 0.0);

#+Z: $axis = length($uv.xy),-$uv.z
#dot(vec2(cos($a*0.01745329251),sin($a*0.01745329251)),vec2($axis))

static func sdf3d_cone_pz(p : Vector3, a : float) -> Vector2:
	var  f : float = Vector2(cos(a*0.01745329251),sin(a*0.01745329251)).dot(Vector2(Vector2(p.x, p.y).length(),-(p).z));

	return Vector2(f, 0.0);


#-Z: $axis = length($uv.xy),$uv.z
#dot(vec2(cos($a*0.01745329251),sin($a*0.01745329251)),vec2($axis))

static func sdf3d_cone_nz(p : Vector3, a : float) -> Vector2:
	var f : float = Vector2(cos(a*0.01745329251),sin(a*0.01745329251)).dot(Vector2(Vector2(p.x, p.y).length(),(p).z));

	return Vector2(f, 0.0);

static func sdf3d_torus_x(p : Vector3, R : float, r : float) -> Vector2:
	var q : Vector2 = Vector2(Vector2(p.y, p.z).length() - R,(p).x);
	var f : float = q.length() - r;

	return Vector2(f, 0.0);
	
static func sdf3d_torus_y(p : Vector3, R : float, r : float) -> Vector2:
	var q : Vector2 = Vector2(Vector2(p.z, p.x).length() - R,(p).y);
	var f : float = q.length() - r;

	return Vector2(f, 0.0);

static func sdf3d_torus_z(p : Vector3, R : float, r : float) -> Vector2:
	var q : Vector2 = Vector2(Vector2(p.x, p.y).length() - R,(p).z);
	var f : float = q.length() - r;

	return Vector2(f, 0.0);


#vec2 raymarch_$name(vec2 uv) {
#	vec3 ro = vec3(uv-vec2(0.5), 1.0);
#	vec3 rd = vec3(0.0, 0.0, -1.0);
#	float dO = 0.0;
#	float c = 0.0;    
#
#	for (int i=0; i < 100; i++) {    
#		vec3 p = ro + rd*dO;        
#		vec2 dS = $sdf(p);        
#		dO += dS.x;        
#
#		if (dO >= 1.0) {
#			break;
#		} else if (dS.x < 0.0001) {
#			c = dS.y;
#			break;
#		}    
#	}        
#
#	return vec2(dO, c);
#}

static func sdf3d_raymarch(uv : Vector2) -> Vector2:
	var ro : Vector3 = Vector3(uv.x - 0.5, uv.y - 0.5, 1.0);
	var rd : Vector3 = Vector3(0.0, 0.0, -1.0);
	var dO : float = 0.0;
	var c : float = 0.0;
	
	for i in range(100):
		var p : Vector3 = ro + rd * dO;
		var dS : Vector2 = sdf3d_input(p);
		
		dO += dS.x;

		if (dO >= 1.0):
			break;
		elif (dS.x < 0.0001):
			c = dS.y;
			break;
	
	return Vector2(dO, c);

#vec3 normal_$name(vec3 p) {
#	if (p.z <= 0.0) {
#		return vec3(0.0, 0.0, 1.0);
#	}
#
#	float d = $sdf(p).x;
#	float e = .001;        
#	vec3 n = d - vec3(        
#		$sdf(p-vec3(e, 0.0, 0.0)).x,        
#		$sdf(p-vec3(0.0, e, 0.0)).x,        
#		$sdf(p-vec3(0.0, 0.0, e)).x);        
#
#	return vec3(-1.0, -1.0, -1.0)*normalize(n);
#}

static func sdf3d_normal(p : Vector3) -> Vector3:
	if (p.z <= 0.0):
		return Vector3(0.0, 0.0, 1.0);

	var d : float = sdf3d_input(p).x;
	var e : float = .001;
	
	var n : Vector3 = Vector3(
		d - sdf3d_input(p - Vector3(e, 0.0, 0.0)).x,
		d - sdf3d_input(p - Vector3(0.0, e, 0.0)).x,
		d - sdf3d_input(p - Vector3(0.0, 0.0, e)).x);
	
	return Vector3(-1.0, -1.0, -1.0) * n.normalized();
	
#vec2 sdf3dc_union(vec2 a, vec2 b) {
#	return vec2(min(a.x, b.x), mix(b.y, a.y, step(a.x, b.x)));
#}

static func sdf3dc_union(a : Vector2, b : Vector2) -> Vector2:
	return Vector2(min(a.x, b.x), lerp(b.y, a.y, Commons.step(a.x, b.x)));

#vec2 sdf3dc_sub(vec2 a, vec2 b) {
#	return vec2(max(-a.x, b.x), a.y);
#}

static func sdf3dc_sub(a : Vector2, b : Vector2) -> Vector2:
	return Vector2(max(-a.x, b.x), a.y);

#vec2 sdf3dc_inter(vec2 a, vec2 b) {
#	return vec2(max(a.x, b.x), mix(a.y, b.y, step(a.x, b.x)));
#}

static func sdf3dc_inter(a : Vector2, b : Vector2) -> Vector2:
	return Vector2(max(a.x, b.x), lerp(a.y, b.y, Commons.step(a.x, b.x)));

#vec2 sdf3d_smooth_union(vec2 d1, vec2 d2, float k) {    
#	float h = clamp(0.5+0.5*(d2.x-d1.x)/k, 0.0, 1.0);    
#	return vec2(mix(d2.x, d1.x, h)-k*h*(1.0-h), mix(d2.y, d1.y, step(d1.x, d2.x)));
#}

static func sdf3d_smooth_union(d1 : Vector2, d2 : Vector2, k : float) -> Vector2:
	var h : float = clamp(0.5 + 0.5 * (d2.x - d1.x) / k, 0.0, 1.0);
	return Vector2(lerp(d2.x, d1.x, h)-k*h*(1.0 - h), lerp(d2.y, d1.y, Commons.step(d1.x, d2.x)));

#vec2 sdf3d_smooth_subtraction(vec2 d1, vec2 d2, float k ) {    
#	float h = clamp(0.5-0.5*(d2.x+d1.x)/k, 0.0, 1.0);    
#	return vec2(mix(d2.x, -d1.x, h )+k*h*(1.0-h), d2.y);
#}

static func sdf3d_smooth_subtraction(d1 : Vector2, d2 : Vector2, k : float) -> Vector2:
	var h : float = clamp(0.5 - 0.5 * (d2.x + d1.x) / k, 0.0, 1.0);
	return Vector2(lerp(d2.x, -d1.x, h )+k*h*(1.0-h), d2.y);

#vec2 sdf3d_smooth_intersection(vec2 d1, vec2 d2, float k ) {    
#	float h = clamp(0.5-0.5*(d2.x-d1.x)/k, 0.0, 1.0);    
#	return vec2(mix(d2.x, d1.x, h)+k*h*(1.0-h), mix(d1.y, d2.y, step(d1.x, d2.x)));
#}

static func sdf3d_smooth_intersection(d1 : Vector2, d2 : Vector2, k : float) -> Vector2:
	var h : float = clamp(0.5 - 0.5 * (d2.x - d1.x) / k, 0.0, 1.0);
	return Vector2(lerp(d2.x, d1.x, h)+k*h*(1.0-h), lerp(d1.y, d2.y, Commons.step(d1.x, d2.x)));

static func sdf3d_rounded(v : Vector2, r : float) -> Vector2:
	return Vector2(v.x - r, v.y);

static func sdf3d_elongation(p : Vector3, v : Vector3) -> Vector3:
	return ((p) - Commons.clampv3((p), - Commons.absv3(v), Commons.absv3(v)))

static func sdf3d_repeat(p : Vector3, r : Vector2, randomness : float, pseed : int) -> Vector3:
	#$in(repeat($uv, vec3(1.0/$rx, 1.0/$ry, 0.0), float($seed), $r))
	return repeat(p, Vector3(1.0 / r.x, 1.0 / r.y, 0.00001), float(pseed), randomness)

#vec3 repeat(vec3 p, vec3 r, float seed, float randomness) {
#	vec3 a = (rand3(floor(mod((p.xy+0.5*r.xy)/r.xy, 1.0/r.xy)+vec2(seed)))-0.5)*6.28*randomness;
#	p = mod(p+0.5*r,r)-0.5*r;
#
#	vec3 rv;
#	float c;
#	float s;
#
#	c = cos(a.x);
#	s = sin(a.x);
#
#	rv.x = p.x;
#	rv.y = p.y*c+p.z*s;rv.z = -p.y*s+p.z*c;
#
#	c = cos(a.y);
#	s = sin(a.y);
#
#	p.x = rv.x*c+rv.z*s;
#	p.y = rv.y;
#	p.z = -rv.x*s+rv.z*c;
#
#	c = cos(a.z);
#	s = sin(a.z);
#
#	rv.x = p.x*c+p.y*s;
#	rv.y = -p.x*s+p.y*c;
#	rv.z = p.z;
#
#	return rv;
#}

static func repeat(p : Vector3, r : Vector3, pseed : float, randomness : float) -> Vector3:
	var a : Vector3 = (Commons.rand3(Commons.floorv2(Commons.modv2((Vector2(p.x, p.y) + Vector2(0.5, 0.5) * Vector2(r.x, r.y)) / Vector2(r.x, r.y), Vector2(1, 1) / Vector2(r.x, r.y)) + Vector2(pseed, pseed))) - Vector3(0.5, 0.5, 0.5)) * 6.28 * randomness
	p = Commons.modv3(p + Vector3(0.5, 0.5, 0.5) * r, r) - Vector3(0.5, 0.5, 0.5) * r;
	
	var rv : Vector3 = Vector3()
	var c : float = 0
	var s : float = 0

	c = cos(a.x);
	s = sin(a.x);

	rv.x = p.x;
	rv.y = p.y* c + p.z * s;
	rv.z = -p.y * s + p.z * c;
	
	c = cos(a.y);
	s = sin(a.y);

	p.x = rv.x*c+rv.z*s;
	p.y = rv.y;
	p.z = -rv.x*s+rv.z*c;

	c = cos(a.z);
	s = sin(a.z);

	rv.x = p.x * c + p.y * s;
	rv.y = -p.x * s + p.y * c;
	rv.z = p.z;
	
	return rv;

#vec3 rotate3d(vec3 p, vec3 a) {
#	vec3 rv;
#	float c;
#	float s;
#	c = cos(a.x);
#	s = sin(a.x);
#	rv.x = p.x;
#	rv.y = p.y*c+p.z*s;
#	rv.z = -p.y*s+p.z*c;
#	c = cos(a.y);
#	s = sin(a.y);
#	p.x = rv.x*c+rv.z*s;
#	p.y = rv.y;
#	p.z = -rv.x*s+rv.z*c;
#	c = cos(a.z);
#	s = sin(a.z);
#	rv.x = p.x*c+p.y*s;
#	rv.y = -p.x*s+p.y*c;
#	rv.z = p.z;
#	return rv;
#}

static func rotate3d(p : Vector3, a : Vector3) -> Vector3:
	var rv : Vector3 = Vector3()
	var c : float = 0
	var s : float = 0
	c = cos(a.x)
	s = sin(a.x)
	rv.x = p.x
	rv.y = p.y * c + p.z * s
	rv.z = -p.y * s + p.z * c
	c = cos(a.y)
	s = sin(a.y)
	p.x = rv.x * c + rv.z * s
	p.y = rv.y
	p.z = -rv.x * s + rv.z * c
	c = cos(a.z)
	s = sin(a.z)
	rv.x = p.x * c + p.y * s
	rv.y = -p.x * s + p.y * c
	rv.z = p.z
	
	return rv

#vec3 circle_repeat_transform(vec3 p, float count) {
#	float r = 6.28/count;
#	float pa = atan(p.x, p.y);
#	float a = mod(pa+0.5*r, r)-0.5*r;
#	vec3 rv;
#	float c = cos(a-pa);
#	float s = sin(a-pa);
#	rv.x = p.x*c+p.y*s;
#	rv.y = -p.x*s+p.y*c;
#	rv.z = p.z;
#	return rv;
#}

static func circle_repeat_transform(p : Vector3, count : float) -> Vector3:
	var r : float = 6.28 / count
	var pa : float = atan2(p.x, p.y)
	var a : float = Commons.modf(pa + 0.5 * r, r) - 0.5 * r
	var rv : Vector3 = Vector3()
	var c : float = cos(a-pa)
	var s : float = sin(a-pa)
	rv.x = p.x * c + p.y * s
	rv.y = -p.x * s + p.y * c
	rv.z = p.z
	return rv

#todo this needs to be solved
static func sdf3d_input(p : Vector3) -> Vector2:
	return sdf3d_sphere(p, 0.5)

#raymarching_preview.mmg
#vec3 render_$name(vec2 uv) {
#	vec3 p = vec3(uv, 2.0-raymarch_$name(vec3(uv, 2.0), vec3(0.0, 0.0, -1.0)));
#	vec3 n = normal_$name(p);
#	vec3 l = vec3(5.0, 5.0, 10.0);
#	vec3 ld = normalize(l-p);
#
#	float o = step(p.z, 0.001);
#	float shadow = 1.0-0.75*step(raymarch_$name(l, -ld), length(l-p)-0.01);
#	float light = 0.3+0.7*dot(n, ld)*shadow;
#
#	return vec3(0.8+0.2*o, 0.8+0.2*o, 1.0)*light;
#}

#static func sdf3d_render(p : Vector2) -> Vector3:
#	return Vector3()
